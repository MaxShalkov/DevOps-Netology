# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"
1. **Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.**
>Builtin. Это системный вызов, который позволяет shell перемещаться по ФС. Вероятнее всего в каком-нибудь кастомном shell вызов chdir() можно сделать с помощью другой команды, а привычные люди сделают себе алиас cd. Но команда унифицирована и смысла в этом как такового нет. 

2. **Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.**
>Команда возвращает кол-во найденных строк. Аналог `grep <some_string> <some_file> -c`

3. **Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?**
>systemd (команда `pstree -p`)

4. **Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?**
>`ls <nonexistfile> 2> /dev/pts/1`

5. **Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.**
>Допустим у нас есть некий файл со строками `echo -e "first\nsecond\nfirst first\nthird" > stdin.file`. Передадим данный файл в grep, выбрав нужные строки и сохраним результат в другой файл: `grep "first" stdin.file 1> stdout.file`.

6. **Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?**
>Получится. Сможем. Эмулятор терминала в графической оболочке взаимодействует напрямую с PTY-master, т.е. обращение идет к `/dev/ptmx`. Для каждой такой сессии создается парная сессия `/dev/pts/x`. Команды, введенные в эмулятор, отправляются в `/dev/ptmx`, откуда благодаря `line discipline` попадают в `/dev/pts/x`.
Результат выполнения операций проделывает обратный путь и отображается в эмуляторе графической оболочки. Такая работа осуществляется благодаря асинхронному процессу обмена данных между PTY-master и PTY-slave, который обеспечивает ОС. Та же удаленная сессия по SSH работает по такому же принципу.
![dashboard](https://github.com/lybomir-dobrynin/DevOps-Netology/blob/main/Homeworks/.img/3.2.1.jpg?raw=true)

7. **Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?**
>Задали перенаправление 5 потока в поток вывода (1). Выполнение команды `echo netology > /proc/$$/fd/5` отправит вывод (1) echo в 5 поток, который в свою очередь перенаправит данные в поток вывода (1). 

8. **Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.**
>Замена потоков через промежуточный дескриптор 
`{ ls file;ls notexistfile; } 3>&1 1>&2 2>&3 | { read in; echo stdin=$in; }`

9. **Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?**
>Команда выведет начальные переменные окружения моего bash процесса. Аналог команды - `printenv`.

10. **Используя man, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`**
>в `cmdline` хранится строка запуска процесса, разделенная и оканчивающаяся `/0`. Файл `exe` есть ни что иное, как мягкая ссылка на фактический путь расположения файла запуска процесса.

11. **Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.**
>sse4_2

12. **При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:**
```
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```
**Почитайте, почему так происходит, и как изменить поведение.**
>При выполнении удаленной команды через ssh не создается псевдо-терминал. Чтобы принудительно его создать, необходимо добавить ключ `-t`

13. **Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.**
>Для Ubuntu 20.04 требуется включить ptrace командой `echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope`. После чего запустить процесс, свернуть `ctrl+z` -> `disown <processname>` -> `screen` -> `reptyr <PID>` -> `Ctrl+AD`.

14. **`sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.**

>`tee` получает данные в stdin, одновременно делает stdout в консоль и в файл(ы). `tee` получит вывод команды `echo`, повысит права до sudo и запишет в файл. `echo` встроена в оболочку, поэтому чтобы такой сценарий сработал, нам нужно запускать новый сеанс `sudo bash`.